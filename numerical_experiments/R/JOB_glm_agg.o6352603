
R version 4.0.4 RC (2021-02-08 r79975) -- "Lost Library Book"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> #' This script aggregates the estimates of power of rejecting H0 in LM
> #' regression problem.
> #' 
> #' Notes: 
> #' cd $ups 
> #' cd numerical_experiments/R
> #' Rnosave 2021-06-10-glm_trt_aggresults.R -N JOB_glm_agg
> 
> 
> rm(list = ls())
> library(here)
> library(tidyverse)
> library(matrixStats)
> 
> # dir to precomputed results
> res_fdir_raw  <- paste0(here::here(), "/numerical_experiments/results_CL/2021-06-08-glm_trt_raw")
> 
> # dir to data saves
> res_fdir_agg  <- paste0(here::here(), "/numerical_experiments/results_CL_shared/2021-06-08-glm_trt_agg")
> dir.create(path = res_fdir_agg)
> 
> # parameters for bootstrap CI computation
> B_bootci     <- 1000  # TODO
> conf_bootci  <- 0.95
> alpha_bootci <- (1 + c(-conf_bootci, conf_bootci))/2
> power_val    <- 0.8
> 
> # read precomputed raw results data 
> fnames_all   <- list.files(res_fdir_raw, full.names = TRUE)
> dat <- do.call("rbind", lapply(fnames_all, readRDS))
> 
> dim(dat)
[1] 80135     5
> head(dat)
  N0 N1 arrayjob_idx          name value
1 70 10            1 upstrap_power 0.116
2 70 11            1 upstrap_power 0.135
3 70 12            1 upstrap_power 0.146
4 70 13            1 upstrap_power 0.176
5 70 14            1 upstrap_power 0.194
6 70 15            1 upstrap_power 0.216
> str(dat)
'data.frame':	80135 obs. of  5 variables:
 $ N0          : num  70 70 70 70 70 70 70 70 70 70 ...
 $ N1          : num  10 11 12 13 14 15 16 17 18 19 ...
 $ arrayjob_idx: num  1 1 1 1 1 1 1 1 1 1 ...
 $ name        : chr  "upstrap_power" "upstrap_power" "upstrap_power" "upstrap_power" ...
 $ value       : num  0.116 0.135 0.146 0.176 0.194 0.216 0.237 0.244 0.268 0.269 ...
> 
> range(dat$N1)
[1]  10 350
> # [1]  10 350
> 
> table(dat$name); Sys.time()

bootstrap_power      run_result   upstrap_power 
          16027           16027           48081 
[1] "2021-06-10 22:56:51 EDT"
> # bootstrap_power      run_result   upstrap_power 
> # 16027           16027           48081 
> # [1] "2021-06-10 22:54:21 EDT"
> 
> # how many out of R=1000 has processed
> paste0("arrayjob_idx count = ", length(unique(dat$arrayjob_idx))) ; Sys.time()
[1] "arrayjob_idx count = 47"
[1] "2021-06-10 22:56:51 EDT"
> # [1] "arrayjob_idx count = 47"
> # [1] "2021-06-10 22:54:34 EDT"
> 
> 
> # ------------------------------------------------------------------------------
> # ------------------------------------------------------------------------------
> # ------------------------------------------------------------------------------
> # PART 1: bootstrap to get power estimates (mean, median) and corresponding CI
> 
> message("Starting PART 1...")
> 
> out_df_all <- data.frame()
> 
> # ------------------------------------------------------------------------------
> # PART 1A: upstrap_bootstrap_power_diff
> 
> name_tmp <- "upstrap_bootstrap_power_diff"
> dat_ups   <- dat %>% filter(name == "upstrap_power")
> dat_bots  <- dat %>% filter(name == "bootstrap_power")
> dim(dat_ups)
[1] 48081     5
> dim(dat_bots)
[1] 16027     5
> 
> dat_value <- 
+   dat_ups %>% 
+   left_join(dat_bots, by = c("N1", "arrayjob_idx")) %>%
+   mutate(value = value.x - value.y,
+          name = name_tmp) %>%
+   select(N0 = N0.x, N1 = N1, arrayjob_idx, name, value)
> dim(dat_value)
[1] 48081     5
> 
> N0_vec <- sort(unique(dat_value$N0))
> N0_vec
[1]  70 120 200
> # [1]  70 120 200
> 
> for (N0_tmp in N0_vec){ # N0_tmp <- 70 
+ 
+   dat_i <- 
+     dat_value %>% 
+     filter(N0 == N0_tmp) %>%
+     select(arrayjob_idx, N1, value) %>% 
+     pivot_wider(names_from = N1, values_from = value) %>%
+     select(-arrayjob_idx) %>% 
+     as.matrix() 
+   dat_i_ncol <- ncol(dat_i)
+   dat_i_nrow <- nrow(dat_i)
+   
+   # bootstrap the statistics: median, mean 
+   dat_i_bootobj_median <- matrix(NA, nrow = B_bootci, ncol = ncol(dat_i))
+   dat_i_bootobj_mean   <- matrix(NA, nrow = B_bootci, ncol = ncol(dat_i))
+   set.seed(123)
+   for (b in 1 : B_bootci){
+     if (b %% 100 == 0) message(b)
+     # resample the dat_value rows
+     resample_b_idx <- sample(1 : dat_i_nrow, replace = TRUE)
+     dat_i_resample_b <- dat_i[resample_b_idx, ]
+     dat_i_bootobj_median[b, ] <- matrixStats::colMedians(dat_i_resample_b)
+     dat_i_bootobj_mean[b, ]   <- matrixStats::colMeans2(dat_i_resample_b)
+   }
+   # bootstrap CI for median
+   dat_i_bootci_median_lwr <-  matrixStats::colQuantiles(dat_i_bootobj_median, probs = alpha_bootci[1])
+   dat_i_bootci_median_upr <-  matrixStats::colQuantiles(dat_i_bootobj_median, probs = alpha_bootci[2])
+   dat_i_median <-  matrixStats::colMedians(dat_i)
+   # bootstrap CI for mean
+   dat_i_bootci_mean_lwr <-  matrixStats::colQuantiles(dat_i_bootobj_mean, probs = alpha_bootci[1])
+   dat_i_bootci_mean_upr <-  matrixStats::colQuantiles(dat_i_bootobj_mean, probs = alpha_bootci[2])
+   dat_i_mean <-  matrixStats::colMeans2(dat_i)
+   # prepare final data frame with these results
+   out_df_i <- data.frame(
+     est_median = dat_i_median,
+     est_median_bootci_lwr = dat_i_bootci_median_lwr,
+     est_median_bootci_upr = dat_i_bootci_median_upr,
+     est_mean = dat_i_mean,
+     est_mean_bootci_lwr = dat_i_bootci_mean_lwr,
+     est_mean_bootci_upr = dat_i_bootci_mean_upr
+   ) %>% mutate(
+     name = rep(name_tmp, dat_i_ncol),
+     N0 = rep(N0_tmp, dat_i_ncol),
+     N1 = as.numeric(colnames(dat_i)), 
+     .before = everything(),
+   )
+   out_df_all <- rbind(out_df_all, out_df_i)
+   rm(out_df_i, dat_i_bootobj_median, dat_i_bootobj_mean, dat_i)
+ }
> 
> 
> # ------------------------------------------------------------------------------
> # PART 1B: upstrap power 
> 
> name_tmp <- "upstrap_power"
> 
> dat_value <- 
+   dat %>% filter(name == name_tmp) %>%
+   select(N0, N1, arrayjob_idx, name, value)
> 
> N0_vec <- sort(unique(dat_value$N0))
> for (N0_tmp in N0_vec){ # N0_tmp <- 20 
+   
+   dat_i <- 
+     dat_value %>% 
+     filter(N0 == N0_tmp)  %>%
+     select(arrayjob_idx, N1, value) %>% 
+     pivot_wider(names_from = N1, values_from = value) %>%
+     select(-arrayjob_idx) %>% 
+     as.matrix() 
+   dat_i_ncol <- ncol(dat_i)
+   dat_i_nrow <- nrow(dat_i)
+   
+   # bootstrap the statistics: median, mean 
+   dat_i_bootobj_median <- matrix(NA, nrow = B_bootci, ncol = ncol(dat_i))
+   dat_i_bootobj_mean   <- matrix(NA, nrow = B_bootci, ncol = ncol(dat_i))
+   set.seed(123)
+   for (b in 1 : B_bootci){
+     if (b %% 100 == 0) message(b)
+     # resample the dat_value rows
+     resample_b_idx <- sample(1 : dat_i_nrow, replace = TRUE)
+     dat_i_resample_b <- dat_i[resample_b_idx, ]
+     dat_i_bootobj_median[b, ] <- matrixStats::colMedians(dat_i_resample_b)
+     dat_i_bootobj_mean[b, ]   <- matrixStats::colMeans2(dat_i_resample_b)
+   }
+   # bootstrap CI for median
+   dat_i_bootci_median_lwr <-  matrixStats::colQuantiles(dat_i_bootobj_median, probs = alpha_bootci[1])
+   dat_i_bootci_median_upr <-  matrixStats::colQuantiles(dat_i_bootobj_median, probs = alpha_bootci[2])
+   dat_i_median <-  matrixStats::colMedians(dat_i)
+   # bootstrap CI for mean
+   dat_i_bootci_mean_lwr <-  matrixStats::colQuantiles(dat_i_bootobj_mean, probs = alpha_bootci[1])
+   dat_i_bootci_mean_upr <-  matrixStats::colQuantiles(dat_i_bootobj_mean, probs = alpha_bootci[2])
+   dat_i_mean <-  matrixStats::colMeans2(dat_i)
+   # prepare final data frame with these results
+   out_df_i <- data.frame(
+     est_median = dat_i_median,
+     est_median_bootci_lwr = dat_i_bootci_median_lwr,
+     est_median_bootci_upr = dat_i_bootci_median_upr,
+     est_mean = dat_i_mean,
+     est_mean_bootci_lwr = dat_i_bootci_mean_lwr,
+     est_mean_bootci_upr = dat_i_bootci_mean_upr
+   ) %>% mutate(
+     name = rep(name_tmp, dat_i_ncol),
+     N0 = rep(N0_tmp, dat_i_ncol),
+     N1 = as.numeric(colnames(dat_i)), 
+     .before = everything(),
+   )
+   
+   out_df_all <- rbind(out_df_all, out_df_i)
+   rm(out_df_i, dat_i_bootobj_median, dat_i_bootobj_mean, dat_i)
+ }
> 
> # ------------------------------------------------------------------------------
> # PART 1C: bootstrap power , run result
> 
> for (name_tmp in c("bootstrap_power", "run_result")){
+   # name_tmp <- "bootstrap_power"
+   dat_value <- 
+     dat %>% filter(name == name_tmp) %>%
+     select(N0, N1, arrayjob_idx, name, value)
+   
+   # no need to iterate over N0 
+   dat_i <- 
+     dat_value %>% 
+     select(arrayjob_idx, N1, value) %>% 
+     pivot_wider(names_from = N1, values_from = value) %>%
+     select(-arrayjob_idx) %>% 
+     as.matrix() 
+   dat_i_ncol <- ncol(dat_i)
+   dat_i_nrow <- nrow(dat_i)
+   
+   # bootstrap the statistics: median, mean 
+   dat_i_bootobj_median <- matrix(NA, nrow = B_bootci, ncol = ncol(dat_i))
+   dat_i_bootobj_mean   <- matrix(NA, nrow = B_bootci, ncol = ncol(dat_i))
+   set.seed(123)
+   for (b in 1 : B_bootci){
+     if (b %% 100 == 0) message(b)
+     # resample the dat_value rows
+     resample_b_idx <- sample(1 : dat_i_nrow, replace = TRUE)
+     dat_i_resample_b <- dat_i[resample_b_idx, ]
+     dat_i_bootobj_median[b, ] <- matrixStats::colMedians(dat_i_resample_b)
+     dat_i_bootobj_mean[b, ]   <- matrixStats::colMeans2(dat_i_resample_b)
+   }
+   # bootstrap CI for median
+   dat_i_bootci_median_lwr <-  matrixStats::colQuantiles(dat_i_bootobj_median, probs = alpha_bootci[1])
+   dat_i_bootci_median_upr <-  matrixStats::colQuantiles(dat_i_bootobj_median, probs = alpha_bootci[2])
+   dat_i_median <-  matrixStats::colMedians(dat_i)
+   # bootstrap CI for mean
+   dat_i_bootci_mean_lwr <-  matrixStats::colQuantiles(dat_i_bootobj_mean, probs = alpha_bootci[1])
+   dat_i_bootci_mean_upr <-  matrixStats::colQuantiles(dat_i_bootobj_mean, probs = alpha_bootci[2])
+   dat_i_mean <-  matrixStats::colMeans2(dat_i)
+   # prepare final data frame with these results
+   out_df_i <- data.frame(
+     est_median = dat_i_median,
+     est_median_bootci_lwr = dat_i_bootci_median_lwr,
+     est_median_bootci_upr = dat_i_bootci_median_upr,
+     est_mean = dat_i_mean,
+     est_mean_bootci_lwr = dat_i_bootci_mean_lwr,
+     est_mean_bootci_upr = dat_i_bootci_mean_upr
+   ) %>% mutate(
+     name = rep(name_tmp, dat_i_ncol),
+     N0 = as.numeric(colnames(dat_i)),
+     N1 = as.numeric(colnames(dat_i)), 
+     .before = everything(),
+   )
+ 
+   out_df_all <- rbind(out_df_all, out_df_i)
+   rm(out_df_i, dat_i_bootobj_median, dat_i_bootobj_mean, dat_i)
+ }
> 
> 
> # ------------------------------------------------------------------------------
> # save the aggregated data 
> 
> saveRDS(out_df_all, paste0(res_fdir_agg, "/glm_trt_power_est_bootCI.rds"))
> message("Saved the results.")
> 
> 
